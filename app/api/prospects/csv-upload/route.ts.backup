import { NextRequest, NextResponse } from 'next/server';
import { createClient } from '@/app/lib/supabase';
import { auth } from '@clerk/nextjs/server';

// Helper function to parse CSV content
function parseCSV(csvContent: string): any[] {
  const lines = csvContent.trim().split('\n');
  if (lines.length < 2) return [];
  
  const headers = lines[0].split(',').map(h => h.trim().toLowerCase().replace(/[^a-z0-9_]/g, '_'));
  const prospects: any[] = [];
  
  for (let i = 1; i < lines.length; i++) {
    const values = lines[i].split(',').map(v => v.trim().replace(/^["']|["']$/g, ''));
    if (values.length < headers.length) continue;
    
    const prospect: any = {};
    headers.forEach((header, index) => {
      if (values[index] && values[index] !== '') {
        // Map common header variations to standard field names
        switch (header) {
          case 'email':
          case 'email_address':
          case 'contact_email':
            prospect.email_address = values[index];
            break;
          case 'linkedin':
          case 'linkedin_url':
          case 'linkedin_profile':
          case 'linkedin_profile_url':
            prospect.linkedin_profile_url = values[index];
            break;
          case 'phone':
          case 'phone_number':
          case 'mobile':
            prospect.phone_number = values[index];
            break;
          case 'company':
          case 'company_name':
          case 'organization':
            prospect.company_name = values[index];
            break;
          case 'name':
          case 'full_name':
          case 'contact_name':
            prospect.full_name = values[index];
            break;
          case 'first_name':
          case 'firstname':
            prospect.first_name = values[index];
            break;
          case 'last_name':
          case 'lastname':
            prospect.last_name = values[index];
            break;
          case 'title':
          case 'job_title':
          case 'position':
            prospect.job_title = values[index];
            break;
          case 'location':
          case 'city':
          case 'country':
            prospect.location = values[index];
            break;
          case 'website':
          case 'company_website':
          case 'domain':
          case 'company_domain':
            prospect.company_domain = values[index];
            break;
          default:
            prospect[header] = values[index];
        }
      }
    });
    
    if (Object.keys(prospect).length > 0) {
      prospects.push(prospect);
    }
  }
  
  return prospects;
}

export async function POST(request: NextRequest) {
  try {
    const { userId } = auth();
    if (!userId) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }

    const body = await request.json();
    const { workspaceId, csvContent, filename, sharingLevel = 'workspace' } = body;

    if (!workspaceId || !csvContent) {
      return NextResponse.json({ 
        error: 'Missing required fields: workspaceId, csvContent' 
      }, { status: 400 });
    }

    const supabase = createClient();

    // Get current user ID
    const { data: userData } = await supabase
      .from('users')
      .select('id')
      .eq('clerk_id', userId)
      .single();

    if (!userData) {
      return NextResponse.json({ error: 'User not found' }, { status: 404 });
    }

    // Verify workspace access
    const { data: membership } = await supabase
      .from('workspace_members')
      .select('*')
      .eq('workspace_id', workspaceId)
      .eq('user_id', userData.id)
      .single();

    if (!membership) {
      return NextResponse.json({ error: 'Access denied to this workspace' }, { status: 403 });
    }

    // Parse CSV content
    console.log('ðŸ“Š Parsing CSV content...');
    const prospects = parseCSV(csvContent);

    if (prospects.length === 0) {
      return NextResponse.json({
        error: 'No valid prospects found in CSV',
        details: 'Make sure your CSV has headers and at least one prospect with email, LinkedIn, or phone number'
      }, { status: 400 });
    }

    console.log('âœ… Parsed', prospects.length, 'prospects from CSV');

    // Use the existing bulk upload endpoint logic
    const validationResults: any[] = [];
    const validProspects: any[] = [];
    let invalidCount = 0;
    
    for (let i = 0; i < prospects.length; i++) {
      const prospect = prospects[i];
      const messages: string[] = [];
      let status = 'valid';
      
      // Check if at least one identifier is provided
      const hasIdentifier = (
        prospect.email_address || 
        prospect.linkedin_profile_url || 
        prospect.phone_number
      );
      
      if (!hasIdentifier) {
        status = 'invalid';
        messages.push('At least one identifier (email, LinkedIn, or phone) is required');
        invalidCount++;
      }
      
      // Validate email format if provided
      if (prospect.email_address) {
        const emailRegex = /^[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Za-z]{2,}$/;
        if (!emailRegex.test(prospect.email_address)) {
          status = 'invalid';
          messages.push('Invalid email format');
          invalidCount++;
        }
      }
      
      validationResults.push({
        row_number: i + 1,
        validation_status: status,
        validation_messages: messages,
        prospect_data: prospect
      });
      
      if (status === 'valid' || status === 'warning') {
        validProspects.push(prospect);
      }
    }

    if (validProspects.length === 0) {
      return NextResponse.json({
        error: 'No valid prospects to upload after validation',
        validation_results: validationResults
      }, { status: 400 });
    }

    // Process prospects with automatic deduplication
    const results: any[] = [];
    let newProspects = 0;
    let updatedProspects = 0;
    let duplicateProspects = 0;

    console.log('ðŸ”„ Processing', validProspects.length, 'prospects with automatic deduplication');

    for (const prospect of validProspects) {
      try {
        const { data: result, error } = await supabase.rpc('add_or_get_workspace_prospect', {
          p_workspace_id: workspaceId,
          p_email_address: prospect.email_address || null,
          p_linkedin_profile_url: prospect.linkedin_profile_url || null,
          p_phone_number: prospect.phone_number || null,
          p_company_domain: prospect.company_domain || null,
          p_full_name: prospect.full_name || null,
          p_first_name: prospect.first_name || null,
          p_last_name: prospect.last_name || null,
          p_job_title: prospect.job_title || null,
          p_company_name: prospect.company_name || null,
          p_location: prospect.location || null,
          p_data_source: 'csv_upload'
        });

        if (error) {
          console.error('Error processing prospect:', error);
          results.push({
            prospect_data: prospect,
            action_taken: 'failed',
            error: error.message,
            prospect_id: null
          });
        } else {
          // Check if this was a new prospect or existing one
          const { data: prospectInfo } = await supabase
            .from('workspace_prospects')
            .select('contact_count, prospect_status, created_at')
            .eq('id', result)
            .single();

          let action = 'created';
          let duplicateReason = null;

          if (prospectInfo) {
            const isNewlyCreated = new Date(prospectInfo.created_at).getTime() > Date.now() - 5000;
            
            if (!isNewlyCreated) {
              if (prospectInfo.contact_count > 0) {
                action = 'skipped';
                duplicateReason = `Already contacted (${prospectInfo.contact_count} times)`;
                duplicateProspects++;
              } else {
                action = 'updated';
                duplicateReason = 'Prospect enriched with new data';
                updatedProspects++;
              }
            } else {
              newProspects++;
            }
          }

          results.push({
            prospect_data: prospect,
            action_taken: action,
            duplicate_reason: duplicateReason,
            prospect_id: result
          });

          // If sharing is enabled, add to shared data pool
          if (sharingLevel !== 'private' && result) {
            await supabase.rpc('auto_share_external_data', {
              p_workspace_id: workspaceId,
              p_user_id: userData.id,
              p_data_source: 'csv_upload',
              p_raw_data: prospect,
              p_data_type: 'prospect'
            }).catch(err => {
              console.warn('Failed to share prospect data:', err);
            });
          }
        }
      } catch (error) {
        console.error('Exception processing prospect:', error);
        results.push({
          prospect_data: prospect,
          action_taken: 'failed',
          error: error instanceof Error ? error.message : 'Unknown error',
          prospect_id: null
        });
      }
    }

    const summary = {
      total_uploaded: prospects.length,
      validation_errors: invalidCount,
      valid_prospects: validProspects.length,
      new_prospects: newProspects,
      updated_prospects: updatedProspects,
      duplicate_prospects: duplicateProspects,
      failed_prospects: results.filter(r => r.action_taken === 'failed').length,
      sharing_level: sharingLevel,
      shared_with_workspace: sharingLevel !== 'private'
    };

    console.log('ðŸ“Š CSV upload complete:', summary);

    return NextResponse.json({
      success: true,
      summary,
      results,
      validation_results: validationResults,
      message: `Successfully processed ${validProspects.length} prospects from CSV. ${newProspects} new, ${updatedProspects} updated, ${duplicateProspects} duplicates automatically handled.`
    });

  } catch (error) {
    console.error('CSV upload error:', error);
    return NextResponse.json({
      error: 'Internal server error',
      details: error instanceof Error ? error.message : 'Unknown error'
    }, { status: 500 });
  }
}